Шаблоны проектирования — это руководства по решению повторяющихся проблем. Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению и сидеть в ожидании чуда. 
Они скорее являются методиками, как решать определенные проблемы в определенных ситуациях.

## 1. Шаблон «Состояние» (State)
Проблема:
Объект должен менять своё поведение в зависимости от внутреннего состояния. Использование множества условных операторов (if/else или switch) делает код громоздким и труднорасширяемым.

### Решение:

Инкапсулировать каждое состояние в отдельный класс.

Делегировать выполнение методов текущему объекту состояния.

Состояния могут переключать контекст на другие состояния.

### Примеры:

Документ (Черновик/Модерация/Опубликован)

В зависимости от состояния методы publish() или edit() ведут себя по-разному.

Торговый автомат

### Состояния: NoCoin, HasCoin, Sold, SoldOut.

Игровой персонаж

Состояния: Idle, Running, Jumping, Attacking.

Влияние многопоточности:
Если состояние изменяется из нескольких потоков, требуется синхронизация (например, std::mutex в C++ или synchronized в Java).

## 2. Шаблон «Посредник» (Mediator)
Проблема:
Множество объектов взаимодействуют друг с другом напрямую, создавая сильную связанность и усложняя поддержку.

### Решение:

Ввести объект-посредник, который централизует взаимодействие.

Компоненты общаются только с посредником, а не друг с другом.

### Примеры:

Чат-приложение

Пользователи отправляют сообщения не напрямую, а через сервер (ChatMediator).

Управление воздушным движением

Диспетчерская вышка координирует самолёты вместо их прямого взаимодействия.

Графический интерфейс (QT)

В Qt QEvent и QObject::event() работают как посредники между виджетами.

Влияние многопоточности:
Посредник может стать узким местом, если обработка сообщений не оптимизирована (например, очередь событий с блокировками).

## 3. Шаблон «Наблюдатель» (Observer)
Проблема:
Необходимо уведомлять множество объектов об изменении состояния одного объекта без жёсткой связанности.

### Решение:

Субъект (Subject) хранит список наблюдателей (Observer).

При изменении состояния субъект уведомляет всех наблюдателей.

### Примеры:

Подписка на новости

Пользователи (Observers) получают уведомления при публикации новой статьи (Subject).

Реактивное программирование (RxJS, ReactiveX)

Потоки данных автоматически обновляют подписчиков.

QT: Сигналы и слоты

```cpp
QObject::connect(button, &QPushButton::clicked, this, &MyClass::onButtonClicked);
```

Влияние многопоточности:

Если наблюдатели выполняются в разных потоках, требуется потокобезопасная очередь событий.

В Qt сигналы могут быть QueuedConnection (асинхронно через event loop).

## Дизайн ПО и влияние многопоточности

Дизайн ПО — это процесс проектирования структуры системы, включая:
Разделение ответственности (принцип единственной обязанности).

Снижение связанности (инкапсуляция, dependency injection).

Повышение связности (логически связанные компоненты группируются).

Использование паттернов для типовых проблем.

### Влияние многопоточности на дизайн
Потокобезопасность

Общие ресурсы требуют синхронизации (mutex, atomic).

Шаблоны типа Наблюдатель могут требовать асинхронной доставки событий.

Масштабируемость

Избегать глобальных блокировок (например, замена Singleton на dependency injection).

Декомпозиция задач

Разделение на независимые компоненты (орторагольные стратегии).

Асинхронные паттерны

Promise/Future, Акторная модель (Akka, Erlang).
